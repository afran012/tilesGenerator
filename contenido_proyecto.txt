Archivo: .gitignore
Ruta: E:\entrenamientomaquina\GenerarTiles\.gitignore
Contenido:
*.pyc
__pycache__/
.ipynb_checkpoints/
data/processed/*
data/output/*
--------------------------------------------------------------------------------

Archivo: contenido_proyecto.txt
Ruta: E:\entrenamientomaquina\GenerarTiles\contenido_proyecto.txt
Contenido:

--------------------------------------------------------------------------------

Archivo: create_project.py
Ruta: E:\entrenamientomaquina\GenerarTiles\create_project.py
Contenido:
import os

def create_project_structure(base_path):
   # Estructura de directorios
   dirs = [
       'data/raw',
       'data/processed',
       'data/output',
       'src/processing',
       'src/utils',
       'notebooks',
       'tests'
   ]
   
   # Crear directorios
   for dir in dirs:
       os.makedirs(os.path.join(base_path, dir), exist_ok=True)

   # Crear archivos
   files = {
       'src/__init__.py': '',
       'src/processing/__init__.py': '',
       'src/processing/tile_generation.py': '',
       'src/utils/__init__.py': '',
       'src/utils/cuda_utils.py': '',
       'src/config.py': '',
       'tests/__init__.py': '',
       'notebooks/exploratory.ipynb': '',
       '.gitignore': '*.pyc\n__pycache__/\n.ipynb_checkpoints/',
       'README.md': '# QGIS Project\n\nDescription of your project here.',
       'environment.yml': '''name: qgis-env
channels:
 - conda-forge
 - pytorch
dependencies:
 - python=3.9
 - pytorch
 - torchvision
 - qgis
 - gdal'''
   }

   for file_path, content in files.items():
       with open(os.path.join(base_path, file_path), 'w') as f:
           f.write(content)

if __name__ == "__main__":
   project_path = input("Ingrese la ruta para el proyecto: ")
   create_project_structure(project_path)
   print(f"Estructura de proyecto creada en {project_path}")
--------------------------------------------------------------------------------

Archivo: environment.yml
Ruta: E:\entrenamientomaquina\GenerarTiles\environment.yml
Contenido:
name: qgis-env
channels:
  - conda-forge
dependencies:
  - python=3.9
  - qgis
  - gdal
  - jupyter
  - numpy
  - pandas
  - matplotlib
  - scikit-learn
  - pip
  - pip:
    - torch==1.12.0+cu124
    - torchvision==0.13.0+cu124
    - torchaudio==0.12.0+cu124
--------------------------------------------------------------------------------

Archivo: estructura_proyecto.txt
Ruta: E:\entrenamientomaquina\GenerarTiles\estructura_proyecto.txt
Contenido:
GenerarTiles/
    .gitignore
    contenido_proyecto.txt
    create_project.py
    environment.yml
    estructura_proyecto.txt
    generate_file_contents.py
    generate_structure.py
    README.md
    symbology-style.db
    validate_environment.py
    validate_qgis_environment.py
    viewer.html
    .git/
        COMMIT_EDITMSG
        config
        description
        HEAD
        index
        hooks/
            applypatch-msg.sample
            commit-msg.sample
            fsmonitor-watchman.sample
            post-update.sample
            pre-applypatch.sample
            pre-commit.sample
            pre-merge-commit.sample
            pre-push.sample
            pre-rebase.sample
            pre-receive.sample
            prepare-commit-msg.sample
            push-to-checkout.sample
            sendemail-validate.sample
            update.sample
        info/
            exclude
        logs/
            HEAD
            refs/
                heads/
                    main
                remotes/
                    origin/
                        main
        objects/
            0d/
                75bb126f919a5213522da936cfed9332f774cb
            26/
                5d3edd71c756c684cc27d0fda060f88ea504fb
            35/
                7017ef9598e0b59a67563a60a429d18ca41364
            45/
                f3164aefb27356d935451ec438c77623d76cf6
            47/
                45cda5c9b40dcc16d7795921c6bd3d55e637cc
            49/
                efd807edba96b0ea258937bb9eaa8572afe917
            52/
                c7b37331b3566dd29b8d3714413741f8ea7d90
            58/
                25e70b37f341bce5247ce4258cb9da370991b7
            63/
                3493882e068514e6949ba82397d81fb832997d
            64/
                6c7429e551081e7b282706c55853a65cabc215
            65/
                ca0b6cf341a1517ce026e4d550a72cded4326c
            68/
                6aac64d663eb68eb383819e2b892f2971090a7
            73/
                4883fb3c80969e472df0dea0266e146b7df049
            79/
                0d8b4b1d6cded2b1d0c00b8224296d56a2ee09
            8a/
                0ada204df62bb702e1f3c8ac53bee1623f15fa
            8c/
                1ef8030875c4e808fe19a0b7a70517508daa54
            96/
                22ab705776007246066da10eabee703f136382
            9d/
                1dcfdaf1a6857c5f83dc27019c7600e1ffaff8
            a8/
                c104abbd9e868394c3794271097426f7c81cb5
            aa/
                820686c41ad6032acba42a5d1b6d79a52977f5
            ad/
                8e420ac011b6901c6206ab3340dfc36fa006b0
            b7/
                1769a186570537489ea0f07fbe6057344a8f0d
            b8/
                2a224b833115870fe432768f8cddee7c27ec83
                c6cf929fcf0974b31b2de55dc5863bb09a2048
            bb/
                3b2343fdef6f4b344b3410aa4aba8f1f9c4481
            c2/
                edfed081464271881aee95cef7e82c2a21a896
            ce/
                56418552555303e9f54b7fec7c691ed8c6cca1
                786c1ccf46c6a974966999e2877c7d9a05338f
            e0/
                10622613481a2d6ba987a8b51990c601b0c706
            e4/
                9b6f8b1dcc0d7a69895da34c47971388f1238e
                d593cf6958bbf3c7b9f53bb1a1b6cc6b5b94aa
            e6/
                9de29bb2d1d6434b8b29ae775ad8c2e48c5391
            ec/
                788f4c4a46b0bc42eda6d9dc453642509ddead
            f0/
                a5fec1f9927fe27b46bd99531e8a89b4fe5ea6
            fc/
                254c1d12b0dc960b499de7fcc0e9fa21921775
            info/
            pack/
        refs/
            heads/
                main
            remotes/
                origin/
                    main
            tags/
    .virtual_documents/
        notebooks/
            tiles.ipynb
    data/
        output/
        processed/
        raw/
    notebooks/
        exploratory.ipynb
        tiles.ipynb
        .ipynb_checkpoints/
            tiles-checkpoint.ipynb
    src/
        config.py
        __init__.py
        processing/
            run-generator.py
            tile_generation.py
            __init__.py
            __pycache__/
                tile_generation.cpython-39.pyc
        utils/
            cuda_utils.py
            dependency_checker.py
            test_qgis_initialization.py
            __init__.py
            __pycache__/
                cuda_utils.cpython-312.pyc
                cuda_utils.cpython-39.pyc
                dependency_checker.cpython-39.pyc
                __init__.cpython-312.pyc
                __init__.cpython-39.pyc
        __pycache__/
            config.cpython-39.pyc
            __init__.cpython-312.pyc
            __init__.cpython-39.pyc
    tests/
        __init__.py

--------------------------------------------------------------------------------

Archivo: generate_file_contents.py
Ruta: E:\entrenamientomaquina\GenerarTiles\generate_file_contents.py
Contenido:
import os

def generate_file_contents(root_dir, output_file):
    with open(output_file, 'w', encoding='utf-8') as f:
        for dirpath, dirnames, filenames in os.walk(root_dir):
            for filename in filenames:
                file_path = os.path.join(dirpath, filename)
                f.write(f'Archivo: {filename}\n')
                f.write(f'Ruta: {file_path}\n')
                f.write('Contenido:\n')
                try:
                    with open(file_path, 'r', encoding='utf-8') as file:
                        f.write(file.read())
                except Exception as e:
                    f.write(f'Error al leer el archivo: {e}\n')
                f.write('\n' + '-'*80 + '\n\n')

if __name__ == "__main__":
    root_directory = os.path.dirname(os.path.abspath(__file__))  # Directorio del proyecto
    output_file = os.path.join(root_directory, 'contenido_proyecto.txt')
    generate_file_contents(root_directory, output_file)
    print(f"Contenido del proyecto guardado en: {output_file}")
--------------------------------------------------------------------------------

Archivo: generate_structure.py
Ruta: E:\entrenamientomaquina\GenerarTiles\generate_structure.py
Contenido:
import os

def generate_structure(root_dir, output_file):
    with open(output_file, 'w') as f:
        for dirpath, dirnames, filenames in os.walk(root_dir):
            level = dirpath.replace(root_dir, '').count(os.sep)
            indent = ' ' * 4 * level
            f.write(f'{indent}{os.path.basename(dirpath)}/\n')
            subindent = ' ' * 4 * (level + 1)
            for filename in filenames:
                f.write(f'{subindent}{filename}\n')

if __name__ == "__main__":
    root_directory = os.path.dirname(os.path.abspath(__file__))  # Directorio del proyecto
    output_file = os.path.join(root_directory, 'estructura_proyecto.txt')
    generate_structure(root_directory, output_file)
    print(f"Estructura del proyecto guardada en: {output_file}")
--------------------------------------------------------------------------------

Archivo: README.md
Ruta: E:\entrenamientomaquina\GenerarTiles\README.md
Contenido:
# QGIS Project Structure Guide


# Proyecto de Generación de Tiles XYZ

## Descripción
Este proyecto genera tiles XYZ utilizando CUDA y Anaconda.

## Estructura del Proyecto
- `data/`: Datos crudos, procesados y de salida.
- `src/`: Código fuente del proyecto.
  - `processing/`: Scripts de procesamiento de datos.
  - `utils/`: Utilidades y funciones auxiliares.
  - `config.py`: Configuraciones del proyecto.
- `notebooks/`: Notebooks de Jupyter para análisis exploratorio.
- `tests/`: Pruebas unitarias.
- `environment.yml`: Dependencias del proyecto.
- `.gitignore`: Archivos ignorados por git.

## Instalación
```bash
conda env create -f [environment.yml](http://_vscodecontentref_/2)
conda activate qgis-env

## Directory Structure

### /data
- `raw/`: Datos originales sin procesar
- `processed/`: Datos procesados intermedios
- `output/`: Resultados finales (teselas XYZ, etc.)

### /src
- `processing/`: Scripts principales de procesamiento
 - `tile_generation.py`: Funciones para generar teselas XYZ
- `utils/`: Funciones auxiliares
 - `cuda_utils.py`: Utilidades CUDA/GPU
- `config.py`: Variables de configuración global

### /notebooks
- `exploratory.ipynb`: Jupyter notebooks para análisis exploratorio

### /tests
- Tests unitarios y de integración

## Archivos de Configuración

- `environment.yml`: Dependencias del proyecto (conda/pip)
- `.gitignore`: Archivos ignorados por git
- `README.md`: Documentación del proyecto

## Orden de Implementación

1. Configurar entorno:
  ```bash
  conda env create -f environment.yml
  conda activate qgis-env#   t i l e s G e n e r a t o r 
 
 
--------------------------------------------------------------------------------

Archivo: symbology-style.db
Ruta: E:\entrenamientomaquina\GenerarTiles\symbology-style.db
Contenido:
Error al leer el archivo: 'utf-8' codec can't decode byte 0xe2 in position 31: invalid continuation byte

--------------------------------------------------------------------------------

Archivo: validate_environment.py
Ruta: E:\entrenamientomaquina\GenerarTiles\validate_environment.py
Contenido:
import os
import sys
from osgeo import gdal

def validate_proj_lib():
    # Posibles ubicaciones de PROJ_LIB
    possible_proj_libs = [
        os.path.join(os.path.dirname(sys.executable), 'Library', 'share', 'proj'),
        r"C:\Program Files\PostgreSQL\15\share\contrib\postgis-3.5\proj"
    ]

    valid_proj_libs = []
    for proj_lib in possible_proj_libs:
        if os.path.exists(proj_lib):
            valid_proj_libs.append(proj_lib)
            print(f"Encontrado PROJ_LIB: {proj_lib}")

    if not valid_proj_libs:
        print("Error: No se encontró una instalación válida de PROJ.")
        return False

    return valid_proj_libs

def validate_gdal():
    try:
        gdal_version = gdal.VersionInfo()
        print(f"GDAL version: {gdal_version}")
        return True
    except Exception as e:
        print(f"Error al verificar la versión de GDAL: {e}")
        return False

def validate_environment():
    print("Validando el entorno de desarrollo...\n")

    # Validar PROJ_LIB
    valid_proj_libs = validate_proj_lib()
    if not valid_proj_libs:
        sys.exit(1)

    # Validar GDAL
    if not validate_gdal():
        sys.exit(1)

    print("\nEntorno de desarrollo validado correctamente.")
    print("Instalaciones de PROJ encontradas:")
    for proj_lib in valid_proj_libs:
        print(f"  - {proj_lib}")

if __name__ == "__main__":
    validate_environment()
--------------------------------------------------------------------------------

Archivo: validate_qgis_environment.py
Ruta: E:\entrenamientomaquina\GenerarTiles\validate_qgis_environment.py
Contenido:
import os
import sys
from pathlib import Path

def setup_qgis_paths():
    # Base QGIS installation path
    qgis_path = Path(r"C:\Program Files\QGIS 3.34.12")
    
    paths = {
        'QGIS_ROOT': qgis_path,
        'QGIS_PREFIX_PATH': qgis_path / 'apps' / 'qgis-ltr',
        'QGIS_PYTHON': qgis_path / 'apps' / 'Python312',
        'QGIS_BIN': qgis_path / 'bin',
    }
    
    # Setup environment variables
    os.environ['QGIS_PREFIX_PATH'] = str(paths['QGIS_PREFIX_PATH'])
    os.environ['PYTHONPATH'] = str(paths['QGIS_PREFIX_PATH'] / 'python')
    os.environ['PATH'] = f"{str(paths['QGIS_BIN'])}{os.pathsep}{os.environ['PATH']}"
    
    # Add paths to sys.path
    python_paths = [
        str(paths['QGIS_PREFIX_PATH'] / 'python'),
        str(paths['QGIS_PYTHON'] / 'Lib' / 'site-packages'),
        str(paths['QGIS_PYTHON']),
        str(paths['QGIS_PREFIX_PATH'] / 'python' / 'plugins'),
    ]
    
    for path in python_paths:
        if path not in sys.path and os.path.exists(path):
            sys.path.append(path)
            print(f"✓ Added to Python path: {path}")
    
    return paths

def validate_paths(paths):
    all_valid = True
    for name, path in paths.items():
        if path.exists():
            print(f"✓ {name} exists: {path}")
        else:
            print(f"✗ {name} not found: {path}")
            all_valid = False
    return all_valid

def test_qgis_imports():
    try:
        print("\nTesting QGIS imports...")
        import qgis.core
        print("✓ Successfully imported qgis.core")
        return True
    except ImportError as e:
        print(f"✗ Failed to import QGIS: {str(e)}")
        return False

def initialize_qgis():
    try:
        print("\nInitializing QGIS...")
        from qgis.core import QgsApplication
        from qgis.analysis import QgsNativeAlgorithms
        
        qgs = QgsApplication([], False)
        qgs.initQgis()
        print("✓ QGIS initialized successfully")
        
        # Test processing algorithms
        print("\nTesting processing algorithms...")
        QgsApplication.processingRegistry().addProvider(QgsNativeAlgorithms())
        print("✓ Native algorithms loaded successfully")
        
        qgs.exitQgis()
        print("✓ QGIS finalized successfully")
        return True
    except Exception as e:
        print(f"✗ Error during QGIS initialization: {str(e)}")
        return False

def main():
    print("QGIS Environment Validator")
    print("-" * 50)
    
    # Setup and validate paths
    print("\nValidating paths...")
    paths = setup_qgis_paths()
    paths_valid = validate_paths(paths)
    
    if not paths_valid:
        print("\n✗ Path validation failed. Please check QGIS installation.")
        return False
    
    # Test QGIS imports
    if not test_qgis_imports():
        print("\n✗ QGIS import test failed. Check Python environment.")
        return False
    
    # Initialize QGIS
    if not initialize_qgis():
        print("\n✗ QGIS initialization failed.")
        return False
    
    print("\n✓ All validations completed successfully!")
    return True

if __name__ == "__main__":
    main()
--------------------------------------------------------------------------------

Archivo: viewer.html
Ruta: E:\entrenamientomaquina\GenerarTiles\viewer.html
Contenido:
<!DOCTYPE html>
<html>
<head>
    <title>Tile Viewer</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css" />
    <style>
        #map {
            height: 100vh;
        }
    </style>
</head>
<body>
    <div id="map"></div>
    <script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"></script>
    <script>
        // Crear el mapa y centrarlo en Itagüí, Colombia
        var map = L.map('map').setView([6.1846, -75.5991], 11);

        // Añadir la capa base de OpenStreetMap
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            maxZoom: 19,
            attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
        }).addTo(map);

        // Añadir los tiles generados
        L.tileLayer('E:/entrenamientomaquina/tiles generados/2018/{z}/{x}/{y}.png', {
            maxZoom: 15,
            attribution: 'Tiles generated by GDAL',
            tms: true  // Asegurarse de que los tiles se carguen correctamente
        }).addTo(map);

        // Ajustar la vista del mapa a los límites de los tiles generados
        var bounds = [[6.0, -76.0], [6.3, -75.3]];  // Ajustar los límites a la región de Itagüí
        map.fitBounds(bounds);
    </script>
</body>
</html>
--------------------------------------------------------------------------------

Archivo: COMMIT_EDITMSG
Ruta: E:\entrenamientomaquina\GenerarTiles\.git\COMMIT_EDITMSG
Contenido:
Add initial project structure with utility and processing modules, environment configuration, and viewer

--------------------------------------------------------------------------------

Archivo: config
Ruta: E:\entrenamientomaquina\GenerarTiles\.git\config
Contenido:
[core]
	repositoryformatversion = 0
	filemode = false
	bare = false
	logallrefupdates = true
	symlinks = false
	ignorecase = true
[remote "origin"]
	url = https://github.com/afran012/tilesGenerator.git
	fetch = +refs/heads/*:refs/remotes/origin/*
[branch "main"]
	remote = origin
	merge = refs/heads/main

--------------------------------------------------------------------------------

Archivo: description
Ruta: E:\entrenamientomaquina\GenerarTiles\.git\description
Contenido:
Unnamed repository; edit this file 'description' to name the repository.

--------------------------------------------------------------------------------

Archivo: HEAD
Ruta: E:\entrenamientomaquina\GenerarTiles\.git\HEAD
Contenido:
ref: refs/heads/main

--------------------------------------------------------------------------------

Archivo: index
Ruta: E:\entrenamientomaquina\GenerarTiles\.git\index
Contenido:
Error al leer el archivo: 'utf-8' codec can't decode byte 0x86 in position 14: invalid start byte

--------------------------------------------------------------------------------

Archivo: applypatch-msg.sample
Ruta: E:\entrenamientomaquina\GenerarTiles\.git\hooks\applypatch-msg.sample
Contenido:
#!/bin/sh
#
# An example hook script to check the commit log message taken by
# applypatch from an e-mail message.
#
# The hook should exit with non-zero status after issuing an
# appropriate message if it wants to stop the commit.  The hook is
# allowed to edit the commit message file.
#
# To enable this hook, rename this file to "applypatch-msg".

. git-sh-setup
commitmsg="$(git rev-parse --git-path hooks/commit-msg)"
test -x "$commitmsg" && exec "$commitmsg" ${1+"$@"}
:

--------------------------------------------------------------------------------

Archivo: commit-msg.sample
Ruta: E:\entrenamientomaquina\GenerarTiles\.git\hooks\commit-msg.sample
Contenido:
#!/bin/sh
#
# An example hook script to check the commit log message.
# Called by "git commit" with one argument, the name of the file
# that has the commit message.  The hook should exit with non-zero
# status after issuing an appropriate message if it wants to stop the
# commit.  The hook is allowed to edit the commit message file.
#
# To enable this hook, rename this file to "commit-msg".

# Uncomment the below to add a Signed-off-by line to the message.
# Doing this in a hook is a bad idea in general, but the prepare-commit-msg
# hook is more suited to it.
#
# SOB=$(git var GIT_AUTHOR_IDENT | sed -n 's/^\(.*>\).*$/Signed-off-by: \1/p')
# grep -qs "^$SOB" "$1" || echo "$SOB" >> "$1"

# This example catches duplicate Signed-off-by lines.

test "" = "$(grep '^Signed-off-by: ' "$1" |
	 sort | uniq -c | sed -e '/^[ 	]*1[ 	]/d')" || {
	echo >&2 Duplicate Signed-off-by lines.
	exit 1
}

--------------------------------------------------------------------------------

Archivo: fsmonitor-watchman.sample
Ruta: E:\entrenamientomaquina\GenerarTiles\.git\hooks\fsmonitor-watchman.sample
Contenido:
#!/usr/bin/perl

use strict;
use warnings;
use IPC::Open2;

# An example hook script to integrate Watchman
# (https://facebook.github.io/watchman/) with git to speed up detecting
# new and modified files.
#
# The hook is passed a version (currently 2) and last update token
# formatted as a string and outputs to stdout a new update token and
# all files that have been modified since the update token. Paths must
# be relative to the root of the working tree and separated by a single NUL.
#
# To enable this hook, rename this file to "query-watchman" and set
# 'git config core.fsmonitor .git/hooks/query-watchman'
#
my ($version, $last_update_token) = @ARGV;

# Uncomment for debugging
# print STDERR "$0 $version $last_update_token\n";

# Check the hook interface version
if ($version ne 2) {
	die "Unsupported query-fsmonitor hook version '$version'.\n" .
	    "Falling back to scanning...\n";
}

my $git_work_tree = get_working_dir();

my $retry = 1;

my $json_pkg;
eval {
	require JSON::XS;
	$json_pkg = "JSON::XS";
	1;
} or do {
	require JSON::PP;
	$json_pkg = "JSON::PP";
};

launch_watchman();

sub launch_watchman {
	my $o = watchman_query();
	if (is_work_tree_watched($o)) {
		output_result($o->{clock}, @{$o->{files}});
	}
}

sub output_result {
	my ($clockid, @files) = @_;

	# Uncomment for debugging watchman output
	# open (my $fh, ">", ".git/watchman-output.out");
	# binmode $fh, ":utf8";
	# print $fh "$clockid\n@files\n";
	# close $fh;

	binmode STDOUT, ":utf8";
	print $clockid;
	print "\0";
	local $, = "\0";
	print @files;
}

sub watchman_clock {
	my $response = qx/watchman clock "$git_work_tree"/;
	die "Failed to get clock id on '$git_work_tree'.\n" .
		"Falling back to scanning...\n" if $? != 0;

	return $json_pkg->new->utf8->decode($response);
}

sub watchman_query {
	my $pid = open2(\*CHLD_OUT, \*CHLD_IN, 'watchman -j --no-pretty')
	or die "open2() failed: $!\n" .
	"Falling back to scanning...\n";

	# In the query expression below we're asking for names of files that
	# changed since $last_update_token but not from the .git folder.
	#
	# To accomplish this, we're using the "since" generator to use the
	# recency index to select candidate nodes and "fields" to limit the
	# output to file names only. Then we're using the "expression" term to
	# further constrain the results.
	my $last_update_line = "";
	if (substr($last_update_token, 0, 1) eq "c") {
		$last_update_token = "\"$last_update_token\"";
		$last_update_line = qq[\n"since": $last_update_token,];
	}
	my $query = <<"	END";
		["query", "$git_work_tree", {$last_update_line
			"fields": ["name"],
			"expression": ["not", ["dirname", ".git"]]
		}]
	END

	# Uncomment for debugging the watchman query
	# open (my $fh, ">", ".git/watchman-query.json");
	# print $fh $query;
	# close $fh;

	print CHLD_IN $query;
	close CHLD_IN;
	my $response = do {local $/; <CHLD_OUT>};

	# Uncomment for debugging the watch response
	# open ($fh, ">", ".git/watchman-response.json");
	# print $fh $response;
	# close $fh;

	die "Watchman: command returned no output.\n" .
	"Falling back to scanning...\n" if $response eq "";
	die "Watchman: command returned invalid output: $response\n" .
	"Falling back to scanning...\n" unless $response =~ /^\{/;

	return $json_pkg->new->utf8->decode($response);
}

sub is_work_tree_watched {
	my ($output) = @_;
	my $error = $output->{error};
	if ($retry > 0 and $error and $error =~ m/unable to resolve root .* directory (.*) is not watched/) {
		$retry--;
		my $response = qx/watchman watch "$git_work_tree"/;
		die "Failed to make watchman watch '$git_work_tree'.\n" .
		    "Falling back to scanning...\n" if $? != 0;
		$output = $json_pkg->new->utf8->decode($response);
		$error = $output->{error};
		die "Watchman: $error.\n" .
		"Falling back to scanning...\n" if $error;

		# Uncomment for debugging watchman output
		# open (my $fh, ">", ".git/watchman-output.out");
		# close $fh;

		# Watchman will always return all files on the first query so
		# return the fast "everything is dirty" flag to git and do the
		# Watchman query just to get it over with now so we won't pay
		# the cost in git to look up each individual file.
		my $o = watchman_clock();
		$error = $output->{error};

		die "Watchman: $error.\n" .
		"Falling back to scanning...\n" if $error;

		output_result($o->{clock}, ("/"));
		$last_update_token = $o->{clock};

		eval { launch_watchman() };
		return 0;
	}

	die "Watchman: $error.\n" .
	"Falling back to scanning...\n" if $error;

	return 1;
}

sub get_working_dir {
	my $working_dir;
	if ($^O =~ 'msys' || $^O =~ 'cygwin') {
		$working_dir = Win32::GetCwd();
		$working_dir =~ tr/\\/\//;
	} else {
		require Cwd;
		$working_dir = Cwd::cwd();
	}

	return $working_dir;
}

--------------------------------------------------------------------------------

Archivo: post-update.sample
Ruta: E:\entrenamientomaquina\GenerarTiles\.git\hooks\post-update.sample
Contenido:
#!/bin/sh
#
# An example hook script to prepare a packed repository for use over
# dumb transports.
#
# To enable this hook, rename this file to "post-update".

exec git update-server-info

--------------------------------------------------------------------------------

Archivo: pre-applypatch.sample
Ruta: E:\entrenamientomaquina\GenerarTiles\.git\hooks\pre-applypatch.sample
Contenido:
#!/bin/sh
#
# An example hook script to verify what is about to be committed
# by applypatch from an e-mail message.
#
# The hook should exit with non-zero status after issuing an
# appropriate message if it wants to stop the commit.
#
# To enable this hook, rename this file to "pre-applypatch".

. git-sh-setup
precommit="$(git rev-parse --git-path hooks/pre-commit)"
test -x "$precommit" && exec "$precommit" ${1+"$@"}
:

--------------------------------------------------------------------------------

Archivo: pre-commit.sample
Ruta: E:\entrenamientomaquina\GenerarTiles\.git\hooks\pre-commit.sample
Contenido:
#!/bin/sh
#
# An example hook script to verify what is about to be committed.
# Called by "git commit" with no arguments.  The hook should
# exit with non-zero status after issuing an appropriate message if
# it wants to stop the commit.
#
# To enable this hook, rename this file to "pre-commit".

if git rev-parse --verify HEAD >/dev/null 2>&1
then
	against=HEAD
else
	# Initial commit: diff against an empty tree object
	against=$(git hash-object -t tree /dev/null)
fi

# If you want to allow non-ASCII filenames set this variable to true.
allownonascii=$(git config --type=bool hooks.allownonascii)

# Redirect output to stderr.
exec 1>&2

# Cross platform projects tend to avoid non-ASCII filenames; prevent
# them from being added to the repository. We exploit the fact that the
# printable range starts at the space character and ends with tilde.
if [ "$allownonascii" != "true" ] &&
	# Note that the use of brackets around a tr range is ok here, (it's
	# even required, for portability to Solaris 10's /usr/bin/tr), since
	# the square bracket bytes happen to fall in the designated range.
	test $(git diff-index --cached --name-only --diff-filter=A -z $against |
	  LC_ALL=C tr -d '[ -~]\0' | wc -c) != 0
then
	cat <<\EOF
Error: Attempt to add a non-ASCII file name.

This can cause problems if you want to work with people on other platforms.

To be portable it is advisable to rename the file.

If you know what you are doing you can disable this check using:

  git config hooks.allownonascii true
EOF
	exit 1
fi

# If there are whitespace errors, print the offending file names and fail.
exec git diff-index --check --cached $against --

--------------------------------------------------------------------------------

Archivo: pre-merge-commit.sample
Ruta: E:\entrenamientomaquina\GenerarTiles\.git\hooks\pre-merge-commit.sample
Contenido:
#!/bin/sh
#
# An example hook script to verify what is about to be committed.
# Called by "git merge" with no arguments.  The hook should
# exit with non-zero status after issuing an appropriate message to
# stderr if it wants to stop the merge commit.
#
# To enable this hook, rename this file to "pre-merge-commit".

. git-sh-setup
test -x "$GIT_DIR/hooks/pre-commit" &&
        exec "$GIT_DIR/hooks/pre-commit"
:

--------------------------------------------------------------------------------

Archivo: pre-push.sample
Ruta: E:\entrenamientomaquina\GenerarTiles\.git\hooks\pre-push.sample
Contenido:
#!/bin/sh

# An example hook script to verify what is about to be pushed.  Called by "git
# push" after it has checked the remote status, but before anything has been
# pushed.  If this script exits with a non-zero status nothing will be pushed.
#
# This hook is called with the following parameters:
#
# $1 -- Name of the remote to which the push is being done
# $2 -- URL to which the push is being done
#
# If pushing without using a named remote those arguments will be equal.
#
# Information about the commits which are being pushed is supplied as lines to
# the standard input in the form:
#
#   <local ref> <local oid> <remote ref> <remote oid>
#
# This sample shows how to prevent push of commits where the log message starts
# with "WIP" (work in progress).

remote="$1"
url="$2"

zero=$(git hash-object --stdin </dev/null | tr '[0-9a-f]' '0')

while read local_ref local_oid remote_ref remote_oid
do
	if test "$local_oid" = "$zero"
	then
		# Handle delete
		:
	else
		if test "$remote_oid" = "$zero"
		then
			# New branch, examine all commits
			range="$local_oid"
		else
			# Update to existing branch, examine new commits
			range="$remote_oid..$local_oid"
		fi

		# Check for WIP commit
		commit=$(git rev-list -n 1 --grep '^WIP' "$range")
		if test -n "$commit"
		then
			echo >&2 "Found WIP commit in $local_ref, not pushing"
			exit 1
		fi
	fi
done

exit 0

--------------------------------------------------------------------------------

Archivo: pre-rebase.sample
Ruta: E:\entrenamientomaquina\GenerarTiles\.git\hooks\pre-rebase.sample
Contenido:
#!/bin/sh
#
# Copyright (c) 2006, 2008 Junio C Hamano
#
# The "pre-rebase" hook is run just before "git rebase" starts doing
# its job, and can prevent the command from running by exiting with
# non-zero status.
#
# The hook is called with the following parameters:
#
# $1 -- the upstream the series was forked from.
# $2 -- the branch being rebased (or empty when rebasing the current branch).
#
# This sample shows how to prevent topic branches that are already
# merged to 'next' branch from getting rebased, because allowing it
# would result in rebasing already published history.

publish=next
basebranch="$1"
if test "$#" = 2
then
	topic="refs/heads/$2"
else
	topic=`git symbolic-ref HEAD` ||
	exit 0 ;# we do not interrupt rebasing detached HEAD
fi

case "$topic" in
refs/heads/??/*)
	;;
*)
	exit 0 ;# we do not interrupt others.
	;;
esac

# Now we are dealing with a topic branch being rebased
# on top of master.  Is it OK to rebase it?

# Does the topic really exist?
git show-ref -q "$topic" || {
	echo >&2 "No such branch $topic"
	exit 1
}

# Is topic fully merged to master?
not_in_master=`git rev-list --pretty=oneline ^master "$topic"`
if test -z "$not_in_master"
then
	echo >&2 "$topic is fully merged to master; better remove it."
	exit 1 ;# we could allow it, but there is no point.
fi

# Is topic ever merged to next?  If so you should not be rebasing it.
only_next_1=`git rev-list ^master "^$topic" ${publish} | sort`
only_next_2=`git rev-list ^master           ${publish} | sort`
if test "$only_next_1" = "$only_next_2"
then
	not_in_topic=`git rev-list "^$topic" master`
	if test -z "$not_in_topic"
	then
		echo >&2 "$topic is already up to date with master"
		exit 1 ;# we could allow it, but there is no point.
	else
		exit 0
	fi
else
	not_in_next=`git rev-list --pretty=oneline ^${publish} "$topic"`
	/usr/bin/perl -e '
		my $topic = $ARGV[0];
		my $msg = "* $topic has commits already merged to public branch:\n";
		my (%not_in_next) = map {
			/^([0-9a-f]+) /;
			($1 => 1);
		} split(/\n/, $ARGV[1]);
		for my $elem (map {
				/^([0-9a-f]+) (.*)$/;
				[$1 => $2];
			} split(/\n/, $ARGV[2])) {
			if (!exists $not_in_next{$elem->[0]}) {
				if ($msg) {
					print STDERR $msg;
					undef $msg;
				}
				print STDERR " $elem->[1]\n";
			}
		}
	' "$topic" "$not_in_next" "$not_in_master"
	exit 1
fi

<<\DOC_END

This sample hook safeguards topic branches that have been
published from being rewound.

The workflow assumed here is:

 * Once a topic branch forks from "master", "master" is never
   merged into it again (either directly or indirectly).

 * Once a topic branch is fully cooked and merged into "master",
   it is deleted.  If you need to build on top of it to correct
   earlier mistakes, a new topic branch is created by forking at
   the tip of the "master".  This is not strictly necessary, but
   it makes it easier to keep your history simple.

 * Whenever you need to test or publish your changes to topic
   branches, merge them into "next" branch.

The script, being an example, hardcodes the publish branch name
to be "next", but it is trivial to make it configurable via
$GIT_DIR/config mechanism.

With this workflow, you would want to know:

(1) ... if a topic branch has ever been merged to "next".  Young
    topic branches can have stupid mistakes you would rather
    clean up before publishing, and things that have not been
    merged into other branches can be easily rebased without
    affecting other people.  But once it is published, you would
    not want to rewind it.

(2) ... if a topic branch has been fully merged to "master".
    Then you can delete it.  More importantly, you should not
    build on top of it -- other people may already want to
    change things related to the topic as patches against your
    "master", so if you need further changes, it is better to
    fork the topic (perhaps with the same name) afresh from the
    tip of "master".

Let's look at this example:

		   o---o---o---o---o---o---o---o---o---o "next"
		  /       /           /           /
		 /   a---a---b A     /           /
		/   /               /           /
	       /   /   c---c---c---c B         /
	      /   /   /             \         /
	     /   /   /   b---b C     \       /
	    /   /   /   /             \     /
    ---o---o---o---o---o---o---o---o---o---o---o "master"


A, B and C are topic branches.

 * A has one fix since it was merged up to "next".

 * B has finished.  It has been fully merged up to "master" and "next",
   and is ready to be deleted.

 * C has not merged to "next" at all.

We would want to allow C to be rebased, refuse A, and encourage
B to be deleted.

To compute (1):

	git rev-list ^master ^topic next
	git rev-list ^master        next

	if these match, topic has not merged in next at all.

To compute (2):

	git rev-list master..topic

	if this is empty, it is fully merged to "master".

DOC_END

--------------------------------------------------------------------------------

Archivo: pre-receive.sample
Ruta: E:\entrenamientomaquina\GenerarTiles\.git\hooks\pre-receive.sample
Contenido:
#!/bin/sh
#
# An example hook script to make use of push options.
# The example simply echoes all push options that start with 'echoback='
# and rejects all pushes when the "reject" push option is used.
#
# To enable this hook, rename this file to "pre-receive".

if test -n "$GIT_PUSH_OPTION_COUNT"
then
	i=0
	while test "$i" -lt "$GIT_PUSH_OPTION_COUNT"
	do
		eval "value=\$GIT_PUSH_OPTION_$i"
		case "$value" in
		echoback=*)
			echo "echo from the pre-receive-hook: ${value#*=}" >&2
			;;
		reject)
			exit 1
		esac
		i=$((i + 1))
	done
fi

--------------------------------------------------------------------------------

Archivo: prepare-commit-msg.sample
Ruta: E:\entrenamientomaquina\GenerarTiles\.git\hooks\prepare-commit-msg.sample
Contenido:
#!/bin/sh
#
# An example hook script to prepare the commit log message.
# Called by "git commit" with the name of the file that has the
# commit message, followed by the description of the commit
# message's source.  The hook's purpose is to edit the commit
# message file.  If the hook fails with a non-zero status,
# the commit is aborted.
#
# To enable this hook, rename this file to "prepare-commit-msg".

# This hook includes three examples. The first one removes the
# "# Please enter the commit message..." help message.
#
# The second includes the output of "git diff --name-status -r"
# into the message, just before the "git status" output.  It is
# commented because it doesn't cope with --amend or with squashed
# commits.
#
# The third example adds a Signed-off-by line to the message, that can
# still be edited.  This is rarely a good idea.

COMMIT_MSG_FILE=$1
COMMIT_SOURCE=$2
SHA1=$3

/usr/bin/perl -i.bak -ne 'print unless(m/^. Please enter the commit message/..m/^#$/)' "$COMMIT_MSG_FILE"

# case "$COMMIT_SOURCE,$SHA1" in
#  ,|template,)
#    /usr/bin/perl -i.bak -pe '
#       print "\n" . `git diff --cached --name-status -r`
# 	 if /^#/ && $first++ == 0' "$COMMIT_MSG_FILE" ;;
#  *) ;;
# esac

# SOB=$(git var GIT_COMMITTER_IDENT | sed -n 's/^\(.*>\).*$/Signed-off-by: \1/p')
# git interpret-trailers --in-place --trailer "$SOB" "$COMMIT_MSG_FILE"
# if test -z "$COMMIT_SOURCE"
# then
#   /usr/bin/perl -i.bak -pe 'print "\n" if !$first_line++' "$COMMIT_MSG_FILE"
# fi

--------------------------------------------------------------------------------

Archivo: push-to-checkout.sample
Ruta: E:\entrenamientomaquina\GenerarTiles\.git\hooks\push-to-checkout.sample
Contenido:
#!/bin/sh

# An example hook script to update a checked-out tree on a git push.
#
# This hook is invoked by git-receive-pack(1) when it reacts to git
# push and updates reference(s) in its repository, and when the push
# tries to update the branch that is currently checked out and the
# receive.denyCurrentBranch configuration variable is set to
# updateInstead.
#
# By default, such a push is refused if the working tree and the index
# of the remote repository has any difference from the currently
# checked out commit; when both the working tree and the index match
# the current commit, they are updated to match the newly pushed tip
# of the branch. This hook is to be used to override the default
# behaviour; however the code below reimplements the default behaviour
# as a starting point for convenient modification.
#
# The hook receives the commit with which the tip of the current
# branch is going to be updated:
commit=$1

# It can exit with a non-zero status to refuse the push (when it does
# so, it must not modify the index or the working tree).
die () {
	echo >&2 "$*"
	exit 1
}

# Or it can make any necessary changes to the working tree and to the
# index to bring them to the desired state when the tip of the current
# branch is updated to the new commit, and exit with a zero status.
#
# For example, the hook can simply run git read-tree -u -m HEAD "$1"
# in order to emulate git fetch that is run in the reverse direction
# with git push, as the two-tree form of git read-tree -u -m is
# essentially the same as git switch or git checkout that switches
# branches while keeping the local changes in the working tree that do
# not interfere with the difference between the branches.

# The below is a more-or-less exact translation to shell of the C code
# for the default behaviour for git's push-to-checkout hook defined in
# the push_to_deploy() function in builtin/receive-pack.c.
#
# Note that the hook will be executed from the repository directory,
# not from the working tree, so if you want to perform operations on
# the working tree, you will have to adapt your code accordingly, e.g.
# by adding "cd .." or using relative paths.

if ! git update-index -q --ignore-submodules --refresh
then
	die "Up-to-date check failed"
fi

if ! git diff-files --quiet --ignore-submodules --
then
	die "Working directory has unstaged changes"
fi

# This is a rough translation of:
#
#   head_has_history() ? "HEAD" : EMPTY_TREE_SHA1_HEX
if git cat-file -e HEAD 2>/dev/null
then
	head=HEAD
else
	head=$(git hash-object -t tree --stdin </dev/null)
fi

if ! git diff-index --quiet --cached --ignore-submodules $head --
then
	die "Working directory has staged changes"
fi

if ! git read-tree -u -m "$commit"
then
	die "Could not update working tree to new HEAD"
fi

--------------------------------------------------------------------------------

Archivo: sendemail-validate.sample
Ruta: E:\entrenamientomaquina\GenerarTiles\.git\hooks\sendemail-validate.sample
Contenido:
#!/bin/sh

# An example hook script to validate a patch (and/or patch series) before
# sending it via email.
#
# The hook should exit with non-zero status after issuing an appropriate
# message if it wants to prevent the email(s) from being sent.
#
# To enable this hook, rename this file to "sendemail-validate".
#
# By default, it will only check that the patch(es) can be applied on top of
# the default upstream branch without conflicts in a secondary worktree. After
# validation (successful or not) of the last patch of a series, the worktree
# will be deleted.
#
# The following config variables can be set to change the default remote and
# remote ref that are used to apply the patches against:
#
#   sendemail.validateRemote (default: origin)
#   sendemail.validateRemoteRef (default: HEAD)
#
# Replace the TODO placeholders with appropriate checks according to your
# needs.

validate_cover_letter () {
	file="$1"
	# TODO: Replace with appropriate checks (e.g. spell checking).
	true
}

validate_patch () {
	file="$1"
	# Ensure that the patch applies without conflicts.
	git am -3 "$file" || return
	# TODO: Replace with appropriate checks for this patch
	# (e.g. checkpatch.pl).
	true
}

validate_series () {
	# TODO: Replace with appropriate checks for the whole series
	# (e.g. quick build, coding style checks, etc.).
	true
}

# main -------------------------------------------------------------------------

if test "$GIT_SENDEMAIL_FILE_COUNTER" = 1
then
	remote=$(git config --default origin --get sendemail.validateRemote) &&
	ref=$(git config --default HEAD --get sendemail.validateRemoteRef) &&
	worktree=$(mktemp --tmpdir -d sendemail-validate.XXXXXXX) &&
	git worktree add -fd --checkout "$worktree" "refs/remotes/$remote/$ref" &&
	git config --replace-all sendemail.validateWorktree "$worktree"
else
	worktree=$(git config --get sendemail.validateWorktree)
fi || {
	echo "sendemail-validate: error: failed to prepare worktree" >&2
	exit 1
}

unset GIT_DIR GIT_WORK_TREE
cd "$worktree" &&

if grep -q "^diff --git " "$1"
then
	validate_patch "$1"
else
	validate_cover_letter "$1"
fi &&

if test "$GIT_SENDEMAIL_FILE_COUNTER" = "$GIT_SENDEMAIL_FILE_TOTAL"
then
	git config --unset-all sendemail.validateWorktree &&
	trap 'git worktree remove -ff "$worktree"' EXIT &&
	validate_series
fi

--------------------------------------------------------------------------------

Archivo: update.sample
Ruta: E:\entrenamientomaquina\GenerarTiles\.git\hooks\update.sample
Contenido:
#!/bin/sh
#
# An example hook script to block unannotated tags from entering.
# Called by "git receive-pack" with arguments: refname sha1-old sha1-new
#
# To enable this hook, rename this file to "update".
#
# Config
# ------
# hooks.allowunannotated
#   This boolean sets whether unannotated tags will be allowed into the
#   repository.  By default they won't be.
# hooks.allowdeletetag
#   This boolean sets whether deleting tags will be allowed in the
#   repository.  By default they won't be.
# hooks.allowmodifytag
#   This boolean sets whether a tag may be modified after creation. By default
#   it won't be.
# hooks.allowdeletebranch
#   This boolean sets whether deleting branches will be allowed in the
#   repository.  By default they won't be.
# hooks.denycreatebranch
#   This boolean sets whether remotely creating branches will be denied
#   in the repository.  By default this is allowed.
#

# --- Command line
refname="$1"
oldrev="$2"
newrev="$3"

# --- Safety check
if [ -z "$GIT_DIR" ]; then
	echo "Don't run this script from the command line." >&2
	echo " (if you want, you could supply GIT_DIR then run" >&2
	echo "  $0 <ref> <oldrev> <newrev>)" >&2
	exit 1
fi

if [ -z "$refname" -o -z "$oldrev" -o -z "$newrev" ]; then
	echo "usage: $0 <ref> <oldrev> <newrev>" >&2
	exit 1
fi

# --- Config
allowunannotated=$(git config --type=bool hooks.allowunannotated)
allowdeletebranch=$(git config --type=bool hooks.allowdeletebranch)
denycreatebranch=$(git config --type=bool hooks.denycreatebranch)
allowdeletetag=$(git config --type=bool hooks.allowdeletetag)
allowmodifytag=$(git config --type=bool hooks.allowmodifytag)

# check for no description
projectdesc=$(sed -e '1q' "$GIT_DIR/description")
case "$projectdesc" in
"Unnamed repository"* | "")
	echo "*** Project description file hasn't been set" >&2
	exit 1
	;;
esac

# --- Check types
# if $newrev is 0000...0000, it's a commit to delete a ref.
zero=$(git hash-object --stdin </dev/null | tr '[0-9a-f]' '0')
if [ "$newrev" = "$zero" ]; then
	newrev_type=delete
else
	newrev_type=$(git cat-file -t $newrev)
fi

case "$refname","$newrev_type" in
	refs/tags/*,commit)
		# un-annotated tag
		short_refname=${refname##refs/tags/}
		if [ "$allowunannotated" != "true" ]; then
			echo "*** The un-annotated tag, $short_refname, is not allowed in this repository" >&2
			echo "*** Use 'git tag [ -a | -s ]' for tags you want to propagate." >&2
			exit 1
		fi
		;;
	refs/tags/*,delete)
		# delete tag
		if [ "$allowdeletetag" != "true" ]; then
			echo "*** Deleting a tag is not allowed in this repository" >&2
			exit 1
		fi
		;;
	refs/tags/*,tag)
		# annotated tag
		if [ "$allowmodifytag" != "true" ] && git rev-parse $refname > /dev/null 2>&1
		then
			echo "*** Tag '$refname' already exists." >&2
			echo "*** Modifying a tag is not allowed in this repository." >&2
			exit 1
		fi
		;;
	refs/heads/*,commit)
		# branch
		if [ "$oldrev" = "$zero" -a "$denycreatebranch" = "true" ]; then
			echo "*** Creating a branch is not allowed in this repository" >&2
			exit 1
		fi
		;;
	refs/heads/*,delete)
		# delete branch
		if [ "$allowdeletebranch" != "true" ]; then
			echo "*** Deleting a branch is not allowed in this repository" >&2
			exit 1
		fi
		;;
	refs/remotes/*,commit)
		# tracking branch
		;;
	refs/remotes/*,delete)
		# delete tracking branch
		if [ "$allowdeletebranch" != "true" ]; then
			echo "*** Deleting a tracking branch is not allowed in this repository" >&2
			exit 1
		fi
		;;
	*)
		# Anything else (is there anything else?)
		echo "*** Update hook: unknown type of update to ref $refname of type $newrev_type" >&2
		exit 1
		;;
esac

# --- Finished
exit 0

--------------------------------------------------------------------------------

Archivo: exclude
Ruta: E:\entrenamientomaquina\GenerarTiles\.git\info\exclude
Contenido:
# git ls-files --others --exclude-from=.git/info/exclude
# Lines that start with '#' are comments.
# For a project mostly in C, the following would be a good set of
# exclude patterns (uncomment them if you want to use them):
# *.[oa]
# *~

--------------------------------------------------------------------------------

Archivo: HEAD
Ruta: E:\entrenamientomaquina\GenerarTiles\.git\logs\HEAD
Contenido:
0000000000000000000000000000000000000000 bb3b2343fdef6f4b344b3410aa4aba8f1f9c4481 afran012 <afran.012@gmail.com> 1733693442 -0500	commit (initial): first commit
bb3b2343fdef6f4b344b3410aa4aba8f1f9c4481 0000000000000000000000000000000000000000 afran012 <afran.012@gmail.com> 1733693442 -0500	Branch: renamed refs/heads/master to refs/heads/main
0000000000000000000000000000000000000000 bb3b2343fdef6f4b344b3410aa4aba8f1f9c4481 afran012 <afran.012@gmail.com> 1733693442 -0500	Branch: renamed refs/heads/master to refs/heads/main
bb3b2343fdef6f4b344b3410aa4aba8f1f9c4481 633493882e068514e6949ba82397d81fb832997d afran012 <afran.012@gmail.com> 1733693456 -0500	commit: Add initial project structure with utility and processing modules, environment configuration, and viewer

--------------------------------------------------------------------------------

Archivo: main
Ruta: E:\entrenamientomaquina\GenerarTiles\.git\logs\refs\heads\main
Contenido:
0000000000000000000000000000000000000000 bb3b2343fdef6f4b344b3410aa4aba8f1f9c4481 afran012 <afran.012@gmail.com> 1733693442 -0500	commit (initial): first commit
bb3b2343fdef6f4b344b3410aa4aba8f1f9c4481 bb3b2343fdef6f4b344b3410aa4aba8f1f9c4481 afran012 <afran.012@gmail.com> 1733693442 -0500	Branch: renamed refs/heads/master to refs/heads/main
bb3b2343fdef6f4b344b3410aa4aba8f1f9c4481 633493882e068514e6949ba82397d81fb832997d afran012 <afran.012@gmail.com> 1733693456 -0500	commit: Add initial project structure with utility and processing modules, environment configuration, and viewer

--------------------------------------------------------------------------------

Archivo: main
Ruta: E:\entrenamientomaquina\GenerarTiles\.git\logs\refs\remotes\origin\main
Contenido:
0000000000000000000000000000000000000000 bb3b2343fdef6f4b344b3410aa4aba8f1f9c4481 afran012 <afran.012@gmail.com> 1733693446 -0500	update by push
bb3b2343fdef6f4b344b3410aa4aba8f1f9c4481 633493882e068514e6949ba82397d81fb832997d afran012 <afran.012@gmail.com> 1733693461 -0500	update by push

--------------------------------------------------------------------------------

Archivo: 75bb126f919a5213522da936cfed9332f774cb
Ruta: E:\entrenamientomaquina\GenerarTiles\.git\objects\0d\75bb126f919a5213522da936cfed9332f774cb
Contenido:
Error al leer el archivo: 'utf-8' codec can't decode byte 0xb4 in position 8: invalid start byte

--------------------------------------------------------------------------------

Archivo: 5d3edd71c756c684cc27d0fda060f88ea504fb
Ruta: E:\entrenamientomaquina\GenerarTiles\.git\objects\26\5d3edd71c756c684cc27d0fda060f88ea504fb
Contenido:
Error al leer el archivo: 'utf-8' codec can't decode byte 0xb2 in position 9: invalid start byte

--------------------------------------------------------------------------------

Archivo: 7017ef9598e0b59a67563a60a429d18ca41364
Ruta: E:\entrenamientomaquina\GenerarTiles\.git\objects\35\7017ef9598e0b59a67563a60a429d18ca41364
Contenido:
Error al leer el archivo: 'utf-8' codec can't decode byte 0xcb in position 4: invalid continuation byte

--------------------------------------------------------------------------------

Archivo: f3164aefb27356d935451ec438c77623d76cf6
Ruta: E:\entrenamientomaquina\GenerarTiles\.git\objects\45\f3164aefb27356d935451ec438c77623d76cf6
Contenido:
Error al leer el archivo: 'utf-8' codec can't decode byte 0xca in position 3: invalid continuation byte

--------------------------------------------------------------------------------

Archivo: 45cda5c9b40dcc16d7795921c6bd3d55e637cc
Ruta: E:\entrenamientomaquina\GenerarTiles\.git\objects\47\45cda5c9b40dcc16d7795921c6bd3d55e637cc
Contenido:
Error al leer el archivo: 'utf-8' codec can't decode byte 0xb0 in position 7: invalid start byte

--------------------------------------------------------------------------------

Archivo: efd807edba96b0ea258937bb9eaa8572afe917
Ruta: E:\entrenamientomaquina\GenerarTiles\.git\objects\49\efd807edba96b0ea258937bb9eaa8572afe917
Contenido:
Error al leer el archivo: 'utf-8' codec can't decode byte 0x88 in position 18: invalid start byte

--------------------------------------------------------------------------------

Archivo: c7b37331b3566dd29b8d3714413741f8ea7d90
Ruta: E:\entrenamientomaquina\GenerarTiles\.git\objects\52\c7b37331b3566dd29b8d3714413741f8ea7d90
Contenido:
Error al leer el archivo: 'utf-8' codec can't decode byte 0x85 in position 2: invalid start byte

--------------------------------------------------------------------------------

Archivo: 25e70b37f341bce5247ce4258cb9da370991b7
Ruta: E:\entrenamientomaquina\GenerarTiles\.git\objects\58\25e70b37f341bce5247ce4258cb9da370991b7
Contenido:
Error al leer el archivo: 'utf-8' codec can't decode byte 0x8d in position 2: invalid start byte

--------------------------------------------------------------------------------

Archivo: 3493882e068514e6949ba82397d81fb832997d
Ruta: E:\entrenamientomaquina\GenerarTiles\.git\objects\63\3493882e068514e6949ba82397d81fb832997d
Contenido:
Error al leer el archivo: 'utf-8' codec can't decode byte 0x95 in position 2: invalid start byte

--------------------------------------------------------------------------------

Archivo: 6c7429e551081e7b282706c55853a65cabc215
Ruta: E:\entrenamientomaquina\GenerarTiles\.git\objects\64\6c7429e551081e7b282706c55853a65cabc215
Contenido:
Error al leer el archivo: 'utf-8' codec can't decode bytes in position 2-3: invalid continuation byte

--------------------------------------------------------------------------------

Archivo: ca0b6cf341a1517ce026e4d550a72cded4326c
Ruta: E:\entrenamientomaquina\GenerarTiles\.git\objects\65\ca0b6cf341a1517ce026e4d550a72cded4326c
Contenido:
Error al leer el archivo: 'utf-8' codec can't decode byte 0x95 in position 2: invalid start byte

--------------------------------------------------------------------------------

Archivo: 6aac64d663eb68eb383819e2b892f2971090a7
Ruta: E:\entrenamientomaquina\GenerarTiles\.git\objects\68\6aac64d663eb68eb383819e2b892f2971090a7
Contenido:
Error al leer el archivo: 'utf-8' codec can't decode byte 0x8e in position 3: invalid start byte

--------------------------------------------------------------------------------

Archivo: 4883fb3c80969e472df0dea0266e146b7df049
Ruta: E:\entrenamientomaquina\GenerarTiles\.git\objects\73\4883fb3c80969e472df0dea0266e146b7df049
Contenido:
Error al leer el archivo: 'utf-8' codec can't decode byte 0x8d in position 2: invalid start byte

--------------------------------------------------------------------------------

Archivo: 0d8b4b1d6cded2b1d0c00b8224296d56a2ee09
Ruta: E:\entrenamientomaquina\GenerarTiles\.git\objects\79\0d8b4b1d6cded2b1d0c00b8224296d56a2ee09
Contenido:
Error al leer el archivo: 'utf-8' codec can't decode byte 0x85 in position 14: invalid start byte

--------------------------------------------------------------------------------

Archivo: 0ada204df62bb702e1f3c8ac53bee1623f15fa
Ruta: E:\entrenamientomaquina\GenerarTiles\.git\objects\8a\0ada204df62bb702e1f3c8ac53bee1623f15fa
Contenido:
Error al leer el archivo: 'utf-8' codec can't decode byte 0xca in position 3: invalid continuation byte

--------------------------------------------------------------------------------

Archivo: 1ef8030875c4e808fe19a0b7a70517508daa54
Ruta: E:\entrenamientomaquina\GenerarTiles\.git\objects\8c\1ef8030875c4e808fe19a0b7a70517508daa54
Contenido:
Error al leer el archivo: 'utf-8' codec can't decode byte 0xd0 in position 18: invalid continuation byte

--------------------------------------------------------------------------------

Archivo: 22ab705776007246066da10eabee703f136382
Ruta: E:\entrenamientomaquina\GenerarTiles\.git\objects\96\22ab705776007246066da10eabee703f136382
Contenido:
Error al leer el archivo: 'utf-8' codec can't decode byte 0xb6 in position 8: invalid start byte

--------------------------------------------------------------------------------

Archivo: 1dcfdaf1a6857c5f83dc27019c7600e1ffaff8
Ruta: E:\entrenamientomaquina\GenerarTiles\.git\objects\9d\1dcfdaf1a6857c5f83dc27019c7600e1ffaff8
Contenido:
Error al leer el archivo: 'utf-8' codec can't decode byte 0xb6 in position 8: invalid start byte

--------------------------------------------------------------------------------

Archivo: c104abbd9e868394c3794271097426f7c81cb5
Ruta: E:\entrenamientomaquina\GenerarTiles\.git\objects\a8\c104abbd9e868394c3794271097426f7c81cb5
Contenido:
Error al leer el archivo: 'utf-8' codec can't decode byte 0xd1 in position 4: invalid continuation byte

--------------------------------------------------------------------------------

Archivo: 820686c41ad6032acba42a5d1b6d79a52977f5
Ruta: E:\entrenamientomaquina\GenerarTiles\.git\objects\aa\820686c41ad6032acba42a5d1b6d79a52977f5
Contenido:
Error al leer el archivo: 'utf-8' codec can't decode byte 0x95 in position 2: invalid start byte

--------------------------------------------------------------------------------

Archivo: 8e420ac011b6901c6206ab3340dfc36fa006b0
Ruta: E:\entrenamientomaquina\GenerarTiles\.git\objects\ad\8e420ac011b6901c6206ab3340dfc36fa006b0
Contenido:
Error al leer el archivo: 'utf-8' codec can't decode byte 0xdd in position 4: invalid continuation byte

--------------------------------------------------------------------------------

Archivo: 1769a186570537489ea0f07fbe6057344a8f0d
Ruta: E:\entrenamientomaquina\GenerarTiles\.git\objects\b7\1769a186570537489ea0f07fbe6057344a8f0d
Contenido:
Error al leer el archivo: 'utf-8' codec can't decode byte 0xed in position 2: invalid continuation byte

--------------------------------------------------------------------------------

Archivo: 2a224b833115870fe432768f8cddee7c27ec83
Ruta: E:\entrenamientomaquina\GenerarTiles\.git\objects\b8\2a224b833115870fe432768f8cddee7c27ec83
Contenido:
Error al leer el archivo: 'utf-8' codec can't decode byte 0x8e in position 3: invalid start byte

--------------------------------------------------------------------------------

Archivo: c6cf929fcf0974b31b2de55dc5863bb09a2048
Ruta: E:\entrenamientomaquina\GenerarTiles\.git\objects\b8\c6cf929fcf0974b31b2de55dc5863bb09a2048
Contenido:
Error al leer el archivo: 'utf-8' codec can't decode byte 0xcd in position 2: invalid continuation byte

--------------------------------------------------------------------------------

Archivo: 3b2343fdef6f4b344b3410aa4aba8f1f9c4481
Ruta: E:\entrenamientomaquina\GenerarTiles\.git\objects\bb\3b2343fdef6f4b344b3410aa4aba8f1f9c4481
Contenido:
Error al leer el archivo: 'utf-8' codec can't decode byte 0x95 in position 2: invalid start byte

--------------------------------------------------------------------------------

Archivo: edfed081464271881aee95cef7e82c2a21a896
Ruta: E:\entrenamientomaquina\GenerarTiles\.git\objects\c2\edfed081464271881aee95cef7e82c2a21a896
Contenido:
Error al leer el archivo: 'utf-8' codec can't decode byte 0xf1 in position 21: invalid continuation byte

--------------------------------------------------------------------------------

Archivo: 56418552555303e9f54b7fec7c691ed8c6cca1
Ruta: E:\entrenamientomaquina\GenerarTiles\.git\objects\ce\56418552555303e9f54b7fec7c691ed8c6cca1
Contenido:
Error al leer el archivo: 'utf-8' codec can't decode byte 0xca in position 3: invalid continuation byte

--------------------------------------------------------------------------------

Archivo: 786c1ccf46c6a974966999e2877c7d9a05338f
Ruta: E:\entrenamientomaquina\GenerarTiles\.git\objects\ce\786c1ccf46c6a974966999e2877c7d9a05338f
Contenido:
Error al leer el archivo: 'utf-8' codec can't decode byte 0x8d in position 2: invalid start byte

--------------------------------------------------------------------------------

Archivo: 10622613481a2d6ba987a8b51990c601b0c706
Ruta: E:\entrenamientomaquina\GenerarTiles\.git\objects\e0\10622613481a2d6ba987a8b51990c601b0c706
Contenido:
Error al leer el archivo: 'utf-8' codec can't decode byte 0x85 in position 2: invalid start byte

--------------------------------------------------------------------------------

Archivo: 9b6f8b1dcc0d7a69895da34c47971388f1238e
Ruta: E:\entrenamientomaquina\GenerarTiles\.git\objects\e4\9b6f8b1dcc0d7a69895da34c47971388f1238e
Contenido:
Error al leer el archivo: 'utf-8' codec can't decode byte 0x8d in position 2: invalid start byte

--------------------------------------------------------------------------------

Archivo: d593cf6958bbf3c7b9f53bb1a1b6cc6b5b94aa
Ruta: E:\entrenamientomaquina\GenerarTiles\.git\objects\e4\d593cf6958bbf3c7b9f53bb1a1b6cc6b5b94aa
Contenido:
Error al leer el archivo: 'utf-8' codec can't decode byte 0x9d in position 2: invalid start byte

--------------------------------------------------------------------------------

Archivo: 9de29bb2d1d6434b8b29ae775ad8c2e48c5391
Ruta: E:\entrenamientomaquina\GenerarTiles\.git\objects\e6\9de29bb2d1d6434b8b29ae775ad8c2e48c5391
Contenido:
Error al leer el archivo: 'utf-8' codec can't decode byte 0xca in position 3: invalid continuation byte

--------------------------------------------------------------------------------

Archivo: 788f4c4a46b0bc42eda6d9dc453642509ddead
Ruta: E:\entrenamientomaquina\GenerarTiles\.git\objects\ec\788f4c4a46b0bc42eda6d9dc453642509ddead
Contenido:
Error al leer el archivo: 'utf-8' codec can't decode byte 0x8d in position 2: invalid start byte

--------------------------------------------------------------------------------

Archivo: a5fec1f9927fe27b46bd99531e8a89b4fe5ea6
Ruta: E:\entrenamientomaquina\GenerarTiles\.git\objects\f0\a5fec1f9927fe27b46bd99531e8a89b4fe5ea6
Contenido:
Error al leer el archivo: 'utf-8' codec can't decode byte 0xad in position 2: invalid start byte

--------------------------------------------------------------------------------

Archivo: 254c1d12b0dc960b499de7fcc0e9fa21921775
Ruta: E:\entrenamientomaquina\GenerarTiles\.git\objects\fc\254c1d12b0dc960b499de7fcc0e9fa21921775
Contenido:
Error al leer el archivo: 'utf-8' codec can't decode byte 0x85 in position 2: invalid start byte

--------------------------------------------------------------------------------

Archivo: main
Ruta: E:\entrenamientomaquina\GenerarTiles\.git\refs\heads\main
Contenido:
633493882e068514e6949ba82397d81fb832997d

--------------------------------------------------------------------------------

Archivo: main
Ruta: E:\entrenamientomaquina\GenerarTiles\.git\refs\remotes\origin\main
Contenido:
633493882e068514e6949ba82397d81fb832997d

--------------------------------------------------------------------------------

Archivo: tiles.ipynb
Ruta: E:\entrenamientomaquina\GenerarTiles\.virtual_documents\notebooks\tiles.ipynb
Contenido:



import os
import sys
from IPython.display import clear_output
import logging

class MemoryOptimizedLogger:
    def __init__(self, max_lines=100):
        self.max_lines = max_lines
        self.line_count = 0
        
    def log(self, message):
        print(message, flush=True)
        self.line_count += 1
        if self.line_count >= self.max_lines:
            clear_output(wait=True)
            self.line_count = 0

logger = MemoryOptimizedLogger()

# Configuración
project_root = os.path.abspath(os.path.join(os.getcwd(), '..'))
sys.path.append(project_root)

import torch
from qgis.core import QgsApplication, QgsRasterLayer
from qgis.analysis import QgsNativeAlgorithms
import processing

input_file = r"E:\work\ProyectoCatasPro\06 ORTOFOTOS - copia\Ortofoto_Itagui_2021.ecw"
output_dir = r"E:\entrenamientomaquina\tiles generados\2021"

def process_tiles():
    try:
        logger.log("Iniciando procesamiento...")
        
        # CUDA check
        logger.log(f"CUDA disponible: {torch.cuda.is_available()}")
        if torch.cuda.is_available():
            logger.log(f"GPU: {torch.cuda.get_device_name(0)}")
            torch.cuda.empty_cache()

        # QGIS init
        qgis_prefix = "C:/OSGeo4W/apps/qgis"
        QgsApplication.setPrefixPath(qgis_prefix, True)
        qgs = QgsApplication([], False)
        qgs.initQgis()
        QgsApplication.processingRegistry().addProvider(QgsNativeAlgorithms())

        logger.log("Cargando raster...")
        raster_layer = QgsRasterLayer(input_file, "ortofoto")
        if not raster_layer.isValid():
            raise ValueError("Capa raster inválida")

        params = {
            'INPUT': raster_layer,
            'ZOOM_MIN': 0,
            'ZOOM_MAX': 18,
            'DPI': 96,
            'TILE_FORMAT': 0,
            'QUALITY': 75,
            'METATILESIZE': 4,
            'TILE_WIDTH': 256,
            'TILE_HEIGHT': 256,
            'TMS_CONVENTION': False,
            'OUTPUT_DIRECTORY': output_dir
        }

        logger.log("Generando tiles...")
        processing.run("gdal:tilesxyz", params)
        logger.log(f"Tiles generados en: {output_dir}")

    except Exception as e:
        logger.log(f"Error: {str(e)}")
    finally:
        qgs.exitQgis()
        torch.cuda.empty_cache()
        logger.log("Proceso finalizado")

process_tiles()


import os
import sys
from src.utils.dependency_checker import DependencyChecker

# Verificar ambiente
checker = DependencyChecker()
status = checker.validate_environment()
checker.print_status(status)




--------------------------------------------------------------------------------

Archivo: exploratory.ipynb
Ruta: E:\entrenamientomaquina\GenerarTiles\notebooks\exploratory.ipynb
Contenido:
{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "vscode": {
     "languageId": "plaintext"
    }
   },
   "outputs": [],
   "source": [
    "{\n",
    " \"cells\": [\n",
    "  {\n",
    "   \"cell_type\": \"code\",\n",
    "   \"execution_count\": null,\n",
    "   \"metadata\": {},\n",
    "   \"source\": [\n",
    "    \"from src.processing.tile_generation import generate_tiles\\n\",\n",
    "    \"generate_tiles()\"\n",
    "   ]\n",
    "  }\n",
    " ]\n",
    "}"
   ]
  }
 ],
 "metadata": {
  "language_info": {
   "name": "python"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}

--------------------------------------------------------------------------------

Archivo: tiles.ipynb
Ruta: E:\entrenamientomaquina\GenerarTiles\notebooks\tiles.ipynb
Contenido:
{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "10b03b9b-f8eb-44ba-910f-2d327d8d3cf1",
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "id": "019755ed-becc-4b88-8c84-d7aaef30265f",
   "metadata": {},
   "outputs": [
    {
     "ename": "ModuleNotFoundError",
     "evalue": "No module named 'torch'",
     "output_type": "error",
     "traceback": [
      "\u001b[1;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[1;31mModuleNotFoundError\u001b[0m                       Traceback (most recent call last)",
      "Cell \u001b[1;32mIn[2], line 24\u001b[0m\n\u001b[0;32m     21\u001b[0m project_root \u001b[38;5;241m=\u001b[39m os\u001b[38;5;241m.\u001b[39mpath\u001b[38;5;241m.\u001b[39mabspath(os\u001b[38;5;241m.\u001b[39mpath\u001b[38;5;241m.\u001b[39mjoin(os\u001b[38;5;241m.\u001b[39mgetcwd(), \u001b[38;5;124m'\u001b[39m\u001b[38;5;124m..\u001b[39m\u001b[38;5;124m'\u001b[39m))\n\u001b[0;32m     22\u001b[0m sys\u001b[38;5;241m.\u001b[39mpath\u001b[38;5;241m.\u001b[39mappend(project_root)\n\u001b[1;32m---> 24\u001b[0m \u001b[38;5;28;01mimport\u001b[39;00m \u001b[38;5;21;01mtorch\u001b[39;00m\n\u001b[0;32m     25\u001b[0m \u001b[38;5;28;01mfrom\u001b[39;00m \u001b[38;5;21;01mqgis\u001b[39;00m\u001b[38;5;21;01m.\u001b[39;00m\u001b[38;5;21;01mcore\u001b[39;00m \u001b[38;5;28;01mimport\u001b[39;00m QgsApplication, QgsRasterLayer\n\u001b[0;32m     26\u001b[0m \u001b[38;5;28;01mfrom\u001b[39;00m \u001b[38;5;21;01mqgis\u001b[39;00m\u001b[38;5;21;01m.\u001b[39;00m\u001b[38;5;21;01manalysis\u001b[39;00m \u001b[38;5;28;01mimport\u001b[39;00m QgsNativeAlgorithms\n",
      "\u001b[1;31mModuleNotFoundError\u001b[0m: No module named 'torch'"
     ]
    }
   ],
   "source": [
    "import os\n",
    "import sys\n",
    "from IPython.display import clear_output\n",
    "import logging\n",
    "\n",
    "class MemoryOptimizedLogger:\n",
    "    def __init__(self, max_lines=100):\n",
    "        self.max_lines = max_lines\n",
    "        self.line_count = 0\n",
    "        \n",
    "    def log(self, message):\n",
    "        print(message, flush=True)\n",
    "        self.line_count += 1\n",
    "        if self.line_count >= self.max_lines:\n",
    "            clear_output(wait=True)\n",
    "            self.line_count = 0\n",
    "\n",
    "logger = MemoryOptimizedLogger()\n",
    "\n",
    "# Configuración\n",
    "project_root = os.path.abspath(os.path.join(os.getcwd(), '..'))\n",
    "sys.path.append(project_root)\n",
    "\n",
    "import torch\n",
    "from qgis.core import QgsApplication, QgsRasterLayer\n",
    "from qgis.analysis import QgsNativeAlgorithms\n",
    "import processing\n",
    "\n",
    "input_file = r\"E:\\work\\ProyectoCatasPro\\06 ORTOFOTOS - copia\\Ortofoto_Itagui_2021.ecw\"\n",
    "output_dir = r\"E:\\entrenamientomaquina\\tiles generados\\2021\"\n",
    "\n",
    "def process_tiles():\n",
    "    try:\n",
    "        logger.log(\"Iniciando procesamiento...\")\n",
    "        \n",
    "        # CUDA check\n",
    "        logger.log(f\"CUDA disponible: {torch.cuda.is_available()}\")\n",
    "        if torch.cuda.is_available():\n",
    "            logger.log(f\"GPU: {torch.cuda.get_device_name(0)}\")\n",
    "            torch.cuda.empty_cache()\n",
    "\n",
    "        # QGIS init\n",
    "        qgis_prefix = \"C:/OSGeo4W/apps/qgis\"\n",
    "        QgsApplication.setPrefixPath(qgis_prefix, True)\n",
    "        qgs = QgsApplication([], False)\n",
    "        qgs.initQgis()\n",
    "        QgsApplication.processingRegistry().addProvider(QgsNativeAlgorithms())\n",
    "\n",
    "        logger.log(\"Cargando raster...\")\n",
    "        raster_layer = QgsRasterLayer(input_file, \"ortofoto\")\n",
    "        if not raster_layer.isValid():\n",
    "            raise ValueError(\"Capa raster inválida\")\n",
    "\n",
    "        params = {\n",
    "            'INPUT': raster_layer,\n",
    "            'ZOOM_MIN': 0,\n",
    "            'ZOOM_MAX': 18,\n",
    "            'DPI': 96,\n",
    "            'TILE_FORMAT': 0,\n",
    "            'QUALITY': 75,\n",
    "            'METATILESIZE': 4,\n",
    "            'TILE_WIDTH': 256,\n",
    "            'TILE_HEIGHT': 256,\n",
    "            'TMS_CONVENTION': False,\n",
    "            'OUTPUT_DIRECTORY': output_dir\n",
    "        }\n",
    "\n",
    "        logger.log(\"Generando tiles...\")\n",
    "        processing.run(\"gdal:tilesxyz\", params)\n",
    "        logger.log(f\"Tiles generados en: {output_dir}\")\n",
    "\n",
    "    except Exception as e:\n",
    "        logger.log(f\"Error: {str(e)}\")\n",
    "    finally:\n",
    "        qgs.exitQgis()\n",
    "        torch.cuda.empty_cache()\n",
    "        logger.log(\"Proceso finalizado\")\n",
    "\n",
    "process_tiles()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "c3e794d8-b551-45ad-bc06-1a3d28e7fe12",
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.12.3"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}

--------------------------------------------------------------------------------

Archivo: tiles-checkpoint.ipynb
Ruta: E:\entrenamientomaquina\GenerarTiles\notebooks\.ipynb_checkpoints\tiles-checkpoint.ipynb
Contenido:
{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "10b03b9b-f8eb-44ba-910f-2d327d8d3cf1",
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "019755ed-becc-4b88-8c84-d7aaef30265f",
   "metadata": {},
   "outputs": [],
   "source": [
    "{\n",
    " \"cells\": [\n",
    "  {\n",
    "   \"cell_type\": \"code\",\n",
    "   \"execution_count\": null,\n",
    "   \"metadata\": {},\n",
    "   \"source\": [\n",
    "    \"import os\\n\",\n",
    "    \"import sys\\n\",\n",
    "    \"from IPython.display import clear_output\\n\",\n",
    "    \"import logging\\n\",\n",
    "    \"\\n\",\n",
    "    \"class MemoryOptimizedLogger:\\n\",\n",
    "    \"    def __init__(self, max_lines=100):\\n\",\n",
    "    \"        self.max_lines = max_lines\\n\",\n",
    "    \"        self.line_count = 0\\n\",\n",
    "    \"        \\n\",\n",
    "    \"    def log(self, message):\\n\",\n",
    "    \"        print(message, flush=True)\\n\",\n",
    "    \"        self.line_count += 1\\n\",\n",
    "    \"        if self.line_count >= self.max_lines:\\n\",\n",
    "    \"            clear_output(wait=True)\\n\",\n",
    "    \"            self.line_count = 0\\n\",\n",
    "    \"\\n\",\n",
    "    \"logger = MemoryOptimizedLogger()\\n\",\n",
    "    \"\\n\",\n",
    "    \"# Configuración\\n\",\n",
    "    \"project_root = os.path.abspath(os.path.join(os.getcwd(), '..'))\\n\",\n",
    "    \"sys.path.append(project_root)\\n\",\n",
    "    \"\\n\",\n",
    "    \"import torch\\n\",\n",
    "    \"from qgis.core import QgsApplication, QgsRasterLayer\\n\",\n",
    "    \"from qgis.analysis import QgsNativeAlgorithms\\n\",\n",
    "    \"import processing\\n\",\n",
    "    \"\\n\",\n",
    "    \"input_file = r\\\"E:\\\\work\\\\ProyectoCatasPro\\\\06 ORTOFOTOS - copia\\\\Ortofoto_Itagui_2021.ecw\\\"\\n\",\n",
    "    \"output_dir = r\\\"E:\\\\entrenamientomaquina\\\\tiles generados\\\\2021\\\"\\n\",\n",
    "    \"\\n\",\n",
    "    \"def process_tiles():\\n\",\n",
    "    \"    try:\\n\",\n",
    "    \"        logger.log(\\\"Iniciando procesamiento...\\\")\\n\",\n",
    "    \"        \\n\",\n",
    "    \"        # CUDA check\\n\",\n",
    "    \"        logger.log(f\\\"CUDA disponible: {torch.cuda.is_available()}\\\")\\n\",\n",
    "    \"        if torch.cuda.is_available():\\n\",\n",
    "    \"            logger.log(f\\\"GPU: {torch.cuda.get_device_name(0)}\\\")\\n\",\n",
    "    \"            torch.cuda.empty_cache()\\n\",\n",
    "    \"\\n\",\n",
    "    \"        # QGIS init\\n\",\n",
    "    \"        qgis_prefix = \\\"C:/OSGeo4W/apps/qgis\\\"\\n\",\n",
    "    \"        QgsApplication.setPrefixPath(qgis_prefix, True)\\n\",\n",
    "    \"        qgs = QgsApplication([], False)\\n\",\n",
    "    \"        qgs.initQgis()\\n\",\n",
    "    \"        QgsApplication.processingRegistry().addProvider(QgsNativeAlgorithms())\\n\",\n",
    "    \"\\n\",\n",
    "    \"        logger.log(\\\"Cargando raster...\\\")\\n\",\n",
    "    \"        raster_layer = QgsRasterLayer(input_file, \\\"ortofoto\\\")\\n\",\n",
    "    \"        if not raster_layer.isValid():\\n\",\n",
    "    \"            raise ValueError(\\\"Capa raster inválida\\\")\\n\",\n",
    "    \"\\n\",\n",
    "    \"        params = {\\n\",\n",
    "    \"            'INPUT': raster_layer,\\n\",\n",
    "    \"            'ZOOM_MIN': 0,\\n\",\n",
    "    \"            'ZOOM_MAX': 18,\\n\",\n",
    "    \"            'DPI': 96,\\n\",\n",
    "    \"            'TILE_FORMAT': 0,\\n\",\n",
    "    \"            'QUALITY': 75,\\n\",\n",
    "    \"            'METATILESIZE': 4,\\n\",\n",
    "    \"            'TILE_WIDTH': 256,\\n\",\n",
    "    \"            'TILE_HEIGHT': 256,\\n\",\n",
    "    \"            'TMS_CONVENTION': False,\\n\",\n",
    "    \"            'OUTPUT_DIRECTORY': output_dir\\n\",\n",
    "    \"        }\\n\",\n",
    "    \"\\n\",\n",
    "    \"        logger.log(\\\"Generando tiles...\\\")\\n\",\n",
    "    \"        processing.run(\\\"gdal:tilesxyz\\\", params)\\n\",\n",
    "    \"        logger.log(f\\\"Tiles generados en: {output_dir}\\\")\\n\",\n",
    "    \"\\n\",\n",
    "    \"    except Exception as e:\\n\",\n",
    "    \"        logger.log(f\\\"Error: {str(e)}\\\")\\n\",\n",
    "    \"    finally:\\n\",\n",
    "    \"        qgs.exitQgis()\\n\",\n",
    "    \"        torch.cuda.empty_cache()\\n\",\n",
    "    \"        logger.log(\\\"Proceso finalizado\\\")\\n\",\n",
    "    \"\\n\",\n",
    "    \"process_tiles()\"\n",
    "   ]\n",
    "  }\n",
    " ]\n",
    "}"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.12.3"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}

--------------------------------------------------------------------------------

Archivo: config.py
Ruta: E:\entrenamientomaquina\GenerarTiles\src\config.py
Contenido:
import os

# Directorios de datos
DATA_DIR = os.path.join(os.path.dirname(__file__), '..', 'data')
RAW_DATA_DIR = os.path.join(DATA_DIR, 'raw')
PROCESSED_DATA_DIR = os.path.join(DATA_DIR, 'processed')
OUTPUT_DATA_DIR = os.path.join(DATA_DIR, 'output')

# Archivo de entrada específico
INPUT_FILE = r"E:\work\ProyectoCatasPro\06 ORTOFOTOS - copia\Ortofoto_Itagui_2021.ecw"

# Directorio de salida específico
OUTPUT_DIR = r"E:\entrenamientomaquina\tiles generados\2021"
--------------------------------------------------------------------------------

Archivo: __init__.py
Ruta: E:\entrenamientomaquina\GenerarTiles\src\__init__.py
Contenido:

--------------------------------------------------------------------------------

Archivo: run-generator.py
Ruta: E:\entrenamientomaquina\GenerarTiles\src\processing\run-generator.py
Contenido:
import os
import sys

def validate_proj_lib():
    # Posibles ubicaciones de PROJ_LIB
    possible_proj_libs = [
        os.path.join(os.path.dirname(sys.executable), 'Library', 'share', 'proj'),
        r"C:\Program Files\PostgreSQL\15\share\contrib\postgis-3.5\proj"
    ]

    for proj_lib in possible_proj_libs:
        if os.path.exists(proj_lib):
            os.environ['PROJ_LIB'] = proj_lib
            print(f"Usando PROJ_LIB: {proj_lib}")
            return True

    print("Error: No se encontró una instalación válida de PROJ.")
    return False

# Validar PROJ_LIB
if not validate_proj_lib():
    sys.exit(1)

# Agregar el directorio del módulo tile_generation al PYTHONPATH
sys.path.append(os.path.join(os.path.dirname(__file__), 'src', 'processing'))

from tile_generation import TileGenerator

# Configura tus rutas
INPUT_FILE = r"E:\entrenamientomaquina\tilescompletos\raster2018.tif"
OUTPUT_DIR = r"E:\entrenamientomaquina\tiles generados\2018"

# Ejecuta el generador
generator = TileGenerator(INPUT_FILE, OUTPUT_DIR)
generator.generate_tiles(zoom_min=16, zoom_max=17)
--------------------------------------------------------------------------------

Archivo: tile_generation.py
Ruta: E:\entrenamientomaquina\GenerarTiles\src\processing\tile_generation.py
Contenido:
import os
import subprocess
import sys
from osgeo import gdal

class TileGenerator:
    def __init__(self, input_file, output_dir):
        self.input_file = input_file
        self.output_dir = output_dir

    def generate_tiles(self, zoom_min=0, zoom_max=18):
        # Validar que el archivo de entrada exista
        if not os.path.exists(self.input_file):
            print(f"Error: El archivo de entrada no existe: {self.input_file}")
            return

        # Validar que el archivo de entrada sea un dataset reconocido por GDAL
        dataset = gdal.Open(self.input_file)
        if dataset is None:
            print(f"Error: El archivo de entrada no es un dataset reconocido por GDAL: {self.input_file}")
            return

        # Validar que el directorio de salida exista, si no, crearlo
        if not os.path.exists(self.output_dir):
            os.makedirs(self.output_dir)
            print(f"Directorio de salida creado: {self.output_dir}")

        # Ruta completa de gdal2tiles.py
        gdal2tiles_path = os.path.join(os.path.dirname(sys.executable), 'Scripts', 'gdal2tiles.py')

        # Comando para generar tiles usando gdal2tiles.py con soporte para CUDA
        command = [
            sys.executable,  # Usar el ejecutable de Python del entorno actual
            gdal2tiles_path,
            '-z', f'{zoom_min}-{zoom_max}',
            '-w', 'none',
            '-r', 'near',  # Resampling method
            '-p', 'mercator',  # Profile
            '-t', 'tiles',  # Title
            '--config', 'GDAL_CACHEMAX', '1024',  # Configurar la caché de GDAL
            '--config', 'GDAL_NUM_THREADS', 'ALL_CPUS',  # Usar todos los núcleos de la CPU
            '--config', 'GDAL_USE_CUDA', 'YES',  # Habilitar el uso de CUDA
            self.input_file,
            self.output_dir
        ]

        # Mostrar el comando que se va a ejecutar
        print(f"Ejecutando comando: {' '.join(command)}")

        # Ejecutar el comando
        try:
            subprocess.run(command, check=True)
            print(f"Tiles generados exitosamente en: {self.output_dir}")
        except subprocess.CalledProcessError as e:
            print(f"Error al generar tiles: {e}")
        except OSError as e:
            print(f"Error al ejecutar gdal2tiles.py: {e}")
--------------------------------------------------------------------------------

Archivo: __init__.py
Ruta: E:\entrenamientomaquina\GenerarTiles\src\processing\__init__.py
Contenido:
from .tile_generation import generate_tiles
--------------------------------------------------------------------------------

Archivo: tile_generation.cpython-39.pyc
Ruta: E:\entrenamientomaquina\GenerarTiles\src\processing\__pycache__\tile_generation.cpython-39.pyc
Contenido:
Error al leer el archivo: 'utf-8' codec can't decode byte 0xe3 in position 16: invalid continuation byte

--------------------------------------------------------------------------------

Archivo: cuda_utils.py
Ruta: E:\entrenamientomaquina\GenerarTiles\src\utils\cuda_utils.py
Contenido:
import torch

def initialize_cuda():
    if torch.cuda.is_available():
        device = torch.device('cuda')
        print(f"Usando dispositivo CUDA: {torch.cuda.get_device_name(device)}")
    else:
        print("CUDA no está disponible. Usando CPU.")
--------------------------------------------------------------------------------

Archivo: dependency_checker.py
Ruta: E:\entrenamientomaquina\GenerarTiles\src\utils\dependency_checker.py
Contenido:
# src/utils/dependency_checker.py
import os
import importlib

class DependencyChecker:
    def __init__(self):
        self.required_packages = ['torch', 'qgis.core', 'osgeo.gdal', 'numpy', 'processing']
        
    def check_cuda(self):
        try:
            import torch
            return {
                'available': torch.cuda.is_available(),
                'device_name': torch.cuda.get_device_name(0) if torch.cuda.is_available() else None,
                'device_count': torch.cuda.device_count() if torch.cuda.is_available() else 0
            }
        except ImportError:
            return {'available': False, 'device_name': None, 'device_count': 0}

    def check_qgis_path(self):
        paths = [
            "C:/OSGeo4W/apps/qgis",
            "C:/Program Files/QGIS 3.40.1",
            os.environ.get('QGIS_PREFIX_PATH', '')
        ]
        for path in paths:
            if path and os.path.exists(path):
                return path
        return None

    def check_package(self, package):
        try:
            importlib.import_module(package)
            return True
        except ImportError:
            return False

    def validate_environment(self):
        return {
            'cuda': self.check_cuda(),
            'qgis_path': self.check_qgis_path(),
            'packages': {pkg: self.check_package(pkg) for pkg in self.required_packages}
        }

    def print_status(self, status):
        print("\n=== Estado del Ambiente ===")
        
        print("\nCUDA:")
        print(f"Disponible: {status['cuda']['available']}")
        if status['cuda']['available']:
            print(f"GPU: {status['cuda']['device_name']}")
            print(f"Dispositivos: {status['cuda']['device_count']}")
            
        print("\nRuta QGIS:")
        print(f"Válida: {status['qgis_path'] is not None}")
        if status['qgis_path']:
            print(f"Ruta: {status['qgis_path']}")
        else:
            print("No se encontró una ruta válida para QGIS. Verifica las siguientes rutas y variables de entorno:")
            print("Rutas verificadas:")
            print("  - C:/OSGeo4W/apps/qgis")
            print("  - C:/Program Files/QGIS 3.40.1")
            print(f"Variable de entorno QGIS_PREFIX_PATH: {os.environ.get('QGIS_PREFIX_PATH', 'No configurada')}")
            
        print("\nPaquetes:")
        for package, installed in status['packages'].items():
            print(f"{package}: {'✓' if installed else '✗'}")

if __name__ == "__main__":
    checker = DependencyChecker()
    status = checker.validate_environment()
    checker.print_status(status)
--------------------------------------------------------------------------------

Archivo: test_qgis_initialization.py
Ruta: E:\entrenamientomaquina\GenerarTiles\src\utils\test_qgis_initialization.py
Contenido:
import os
import sys

# Asegúrate de que la variable de entorno QGIS_PREFIX_PATH esté configurada correctamente
qgis_prefix_path = os.environ.get('QGIS_PREFIX_PATH', 'C:/OSGeo4W/apps/qgis')
os.environ['QGIS_PREFIX_PATH'] = qgis_prefix_path

# Agregar las rutas necesarias a sys.path
sys.path.append(os.path.join(qgis_prefix_path, 'python'))
sys.path.append(os.path.join(qgis_prefix_path, 'python', 'plugins'))

try:
    from qgis.core import QgsApplication, QgsRasterLayer
    from qgis.analysis import QgsNativeAlgorithms
    import processing

    # Inicializar QGIS
    QgsApplication.setPrefixPath(qgis_prefix_path, True)
    qgs = QgsApplication([], False)
    qgs.initQgis()
    
    # Añadir algoritmos nativos de QGIS
    QgsApplication.processingRegistry().addProvider(QgsNativeAlgorithms())

    print("QGIS inicializado correctamente.")
    
    # Finalizar QGIS
    qgs.exitQgis()
    print("QGIS finalizado.")
except ImportError as e:
    print(f"Error al importar módulos de QGIS: {e}")
except Exception as e:
    print(f"Error al inicializar QGIS: {e}")
--------------------------------------------------------------------------------

Archivo: __init__.py
Ruta: E:\entrenamientomaquina\GenerarTiles\src\utils\__init__.py
Contenido:
from .cuda_utils import initialize_cuda
--------------------------------------------------------------------------------

Archivo: cuda_utils.cpython-312.pyc
Ruta: E:\entrenamientomaquina\GenerarTiles\src\utils\__pycache__\cuda_utils.cpython-312.pyc
Contenido:
Error al leer el archivo: 'utf-8' codec can't decode byte 0xcb in position 0: invalid continuation byte

--------------------------------------------------------------------------------

Archivo: cuda_utils.cpython-39.pyc
Ruta: E:\entrenamientomaquina\GenerarTiles\src\utils\__pycache__\cuda_utils.cpython-39.pyc
Contenido:
Error al leer el archivo: 'utf-8' codec can't decode byte 0x93 in position 8: invalid start byte

--------------------------------------------------------------------------------

Archivo: dependency_checker.cpython-39.pyc
Ruta: E:\entrenamientomaquina\GenerarTiles\src\utils\__pycache__\dependency_checker.cpython-39.pyc
Contenido:
Error al leer el archivo: 'utf-8' codec can't decode byte 0x9e in position 8: invalid start byte

--------------------------------------------------------------------------------

Archivo: __init__.cpython-312.pyc
Ruta: E:\entrenamientomaquina\GenerarTiles\src\utils\__pycache__\__init__.cpython-312.pyc
Contenido:
Error al leer el archivo: 'utf-8' codec can't decode byte 0xcb in position 0: invalid continuation byte

--------------------------------------------------------------------------------

Archivo: __init__.cpython-39.pyc
Ruta: E:\entrenamientomaquina\GenerarTiles\src\utils\__pycache__\__init__.cpython-39.pyc
Contenido:
Error al leer el archivo: 'utf-8' codec can't decode byte 0x8c in position 9: invalid start byte

--------------------------------------------------------------------------------

Archivo: config.cpython-39.pyc
Ruta: E:\entrenamientomaquina\GenerarTiles\src\__pycache__\config.cpython-39.pyc
Contenido:
Error al leer el archivo: 'utf-8' codec can't decode byte 0xe1 in position 12: invalid continuation byte

--------------------------------------------------------------------------------

Archivo: __init__.cpython-312.pyc
Ruta: E:\entrenamientomaquina\GenerarTiles\src\__pycache__\__init__.cpython-312.pyc
Contenido:
Error al leer el archivo: 'utf-8' codec can't decode byte 0xcb in position 0: invalid continuation byte

--------------------------------------------------------------------------------

Archivo: __init__.cpython-39.pyc
Ruta: E:\entrenamientomaquina\GenerarTiles\src\__pycache__\__init__.cpython-39.pyc
Contenido:
Error al leer el archivo: 'utf-8' codec can't decode byte 0x86 in position 9: invalid start byte

--------------------------------------------------------------------------------

Archivo: __init__.py
Ruta: E:\entrenamientomaquina\GenerarTiles\tests\__init__.py
Contenido:

--------------------------------------------------------------------------------

